var SNIP = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5); temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \tmat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, row ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:row));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(row)), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[row, ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[row, ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:row){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t} \t\t\telse { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:row){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:row){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=row || (cnt==(row-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet) \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = mat, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE);");

var augcoeff = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5); temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex(f, TRUE)");

var mysnippet = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5); temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \tmat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, nrow(mat) ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:nrow(mat)));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(nrow(mat))), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[nrow(mat), ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[nrow(mat), ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:nrow(mat)){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t}else { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:nrow(mat)){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:nrow(mat)){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet); \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = mat, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE)");

// var mysnippet = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5); temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \tmat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, nrow(mat) ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:nrow(mat)));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(nrow(mat))), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[nrow(mat), ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[nrow(mat), ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:nrow(mat)){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t}else { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:nrow(mat)){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:nrow(mat)){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet); \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = mat, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE)");
// var mysnippet = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5); temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \tmat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, nrow(mat) ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:nrow(mat)));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(nrow(mat))), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[nrow(mat), ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[nrow(mat), ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:nrow(mat)){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t}else { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:nrow(mat)){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:nrow(mat)){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet); \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = mat, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE)");
// var mysnippet = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5); temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \tmat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, nrow(mat) ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:nrow(mat)));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(nrow(mat))), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[nrow(mat), ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[nrow(mat), ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:nrow(mat)){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t}else { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:nrow(mat)){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:nrow(mat)){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet); \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = mat, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE)");

// var fxns = "E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5);";
var code = " temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \t   matlist = NULL; \t mat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, nrow(mat) ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:nrow(mat)));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(nrow(mat))), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[nrow(mat), ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[nrow(mat), ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:nrow(mat)){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t}else { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:nrow(mat)){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:nrow(mat)){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet); \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t matlist[[iter]] <- mat;    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = matlist, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE);";
// var snipetty = new ocpu.Snippet(fxn+code);

var mysnippet2 = new ocpu.Snippet(" temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \tmat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, nrow(mat) ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:nrow(mat)));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(nrow(mat))), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[nrow(mat), ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[nrow(mat), ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:nrow(mat)){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t}else { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:nrow(mat)){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:nrow(mat)){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet); \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = mat, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE)");


var fxns = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5);");