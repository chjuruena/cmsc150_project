var SNIP = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5); temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \tmat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, row ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:row));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(row)), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[row, ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[row, ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:row){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t} \t\t\telse { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:row){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:row){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=row || (cnt==(row-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet) \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = mat, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE);");

var augcoeff = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5); temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex(f, TRUE)");

var mysnippet = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5); temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \tmat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, nrow(mat) ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:nrow(mat)));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(nrow(mat))), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[nrow(mat), ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[nrow(mat), ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:nrow(mat)){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t}else { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:nrow(mat)){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:nrow(mat)){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet); \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = mat, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE)");

// var mysnippet = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5); temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \tmat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, nrow(mat) ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:nrow(mat)));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(nrow(mat))), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[nrow(mat), ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[nrow(mat), ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:nrow(mat)){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t}else { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:nrow(mat)){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:nrow(mat)){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet); \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = mat, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE)");
// var mysnippet = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5); temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \tmat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, nrow(mat) ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:nrow(mat)));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(nrow(mat))), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[nrow(mat), ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[nrow(mat), ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:nrow(mat)){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t}else { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:nrow(mat)){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:nrow(mat)){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet); \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = mat, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE)");
// var mysnippet = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5); temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \tmat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, nrow(mat) ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:nrow(mat)));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(nrow(mat))), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[nrow(mat), ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[nrow(mat), ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:nrow(mat)){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t}else { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:nrow(mat)){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:nrow(mat)){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet); \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = mat, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE)");

// var fxns = "E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5);";
var maxi = " mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; diagSlack = NULL; newmat = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; Simplex <- function(f, verbose){   matlist = NULL;   mat = AugCoeffMatrix(f)$augcoeffmatrix;   var = AugCoeffMatrix(f)$variables;   row = nrow(mat);         diagSlack = diag(x = 1, nrow(mat) );   for (k in 1:length(var)){     newmat = cbind (newmat, mat[,k]);   };   newmat = cbind(newmat, diagSlack);   newmat = cbind(newmat, mat[,ncol(mat)]);   mat = newmat;      col = ncol(mat);   slack = c(paste(\"s\", 1:nrow(mat), sep=\"\"));   label = c(var, slack, \"S\");      dimnames(mat)=list(c(1:row), label);   print(mat);      iter = 1;   solutionSet = c();   while( min(mat[nrow(mat), ]) < 0){     solutionSet = c();     pivotcol = which.min((mat[nrow(mat), ]));     temp = c();     for (i in 1:nrow(mat)){       x = as.numeric(mat[i, col]/mat[i,pivotcol]);       if(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){         temp = c(temp, Inf);       }else {         temp = c(temp, x);       };     };     pivotrow = as.numeric(which.min(abs(temp)));     mat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4);     for(j in 1:nrow(mat)){       if(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) {         next;       };       normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);       mat[j,] = round(mat[j,] - normalized, digits = 4);       if(verbose){         print(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE);         print(mat);       };     };      solutionSet = c();     for(j in 1:col){       cnt = 0;       for(k in 1:nrow(mat)){         if (mat[k,j] == 0){           cnt = cnt + 1;         };         if(mat[k,j] == 1){           temp = mat[k,col];         };       };       if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){         solutionSet = c(solutionSet, temp);       }else{         solutionSet = c(solutionSet, 0);       };     };     names(solutionSet)=label;     if(verbose){        print(paste(\"******************************************\"),quote = FALSE);       print(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE);       print(mat);       print(paste(\"Solution Set: \"),quote = FALSE);       print(paste(\"******************************************\"),quote = FALSE);      };     matlist[[iter]] <- mat;     iter=iter+1;      if(min((mat[row, ]))>0) break;   };     if(verbose){     print(paste(\"Resulting Matrix for Simplex\"),quote = FALSE);     print(mat);     print(paste(\"Solution Set: \"),quote = FALSE);     print(solutionSet);   };   result = list(mat = matlist, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   return (result); };   Simplex(f, FALSE);";
var mini = " mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; sslabel = NULL; iter = NULL; temp = NULL; varlen= NULL; z = NULL; slackCnt = NULL; cnter = NULL; newmat=NULL;  AugCoeffMatrix <- function(mylist){   tempstring = NULL;   i = 1;   row = NULL;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };      mat = t(mat);   row = nrow(mat);      tempstring = c(paste(\"x\", (length(vars)+1):(len-1), sep=\"\"));   vars = c(vars, tempstring);         dimnames(mat)=list(c(1:row), c(vars, \"RHS\"));      result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); };  Simplex <- function(f, verbose){   matlist = NULL;   mat = AugCoeffMatrix(f)$augcoeffmatrix;   var = AugCoeffMatrix(f)$variables;          row = nrow(mat);   mat[row,] = mat[row,] *-1;    diagSlack = diag(x = 1, length(var) );   slackCnt = ncol(diagSlack);         for (k in 1:length(var)){     newmat = cbind (newmat, mat[,k]);   };   newmat = cbind(newmat, diagSlack);   newmat = cbind(newmat, mat[,ncol(mat)]);   mat = newmat;         col = ncol(mat);   slack = c(paste(\"s\", 1:nrow(mat), sep=\"\"));   label = c(var, slack, \"S\");   dimnames(mat)=list(c(1:row), label);    iter = 1;   solutionSet = c();   while( min(mat[nrow(mat), ]) < 0){     solutionSet = c();     pivotcol = which.min((mat[nrow(mat), ]));     temp = c();     for (i in 1:nrow(mat)){       x = as.numeric(mat[i, col]/mat[i,pivotcol]);       if(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){         temp = c(temp, Inf);       }else {         temp = c(temp, x);       };     };     pivotrow = as.numeric(which.min(abs(temp)));     mat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4);     for(j in 1:nrow(mat)){       if(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) {         next;       };       normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);       mat[j,] = round(mat[j,] - normalized, digits = 4);       if(verbose){         print(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE);         print(mat);       };     };      solutionSet = c();     sslabel = c();          for(z in slackCnt:2){       solutionSet = c(solutionSet, mat[row, (col-z)] );     };     for(z in 2:slackCnt){       sslabel = c(sslabel, var[z]);     };     names(solutionSet)=sslabel;     if(verbose){        print(paste(\"******************************************\"),quote = FALSE);       print(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE);       print(mat);       print(paste(\"Solution Set: \"),quote = FALSE);       print(solutionSet);       print(paste(\"******************************************\"),quote = FALSE);      };     matlist[[iter]] <- mat;     iter=iter+1;      if(min((mat[row, ]))>0) break;   };     if(verbose){     print(paste(\"Resulting Matrix for Simplex\"),quote = FALSE);     print(mat);     print(paste(\"Solution Set: \"),quote = FALSE);     print(solutionSet);   };   result = list(mat = matlist, solutionSet = solutionSet);   return (result); };  Simplex(f, FALSE);";
//working maximization:
var code = " temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \t   matlist = NULL; \t mat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, nrow(mat) ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:nrow(mat), sep=\"\"));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(nrow(mat))), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[nrow(mat), ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[nrow(mat), ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:nrow(mat)){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t}else { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:nrow(mat)){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:nrow(mat)){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet); \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t matlist[[iter]] <- mat;    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = matlist, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE);";
// var snipetty = new ocpu.Snippet(fxn+code);

var mysnippet2 = new ocpu.Snippet(" temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \tmat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, nrow(mat) ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:nrow(mat), sep=\"\"));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(nrow(mat))), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[nrow(mat), ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[nrow(mat), ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:nrow(mat)){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t}else { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:nrow(mat)){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:nrow(mat)){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet); \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = mat, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE)");


var fxns = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5);");