var SNIP = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5); temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \tmat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, row ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:row));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(row)), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[row, ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[row, ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:row){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t} \t\t\telse { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:row){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:row){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=row || (cnt==(row-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet) \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = mat, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE);");

var augcoeff = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5); temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex(f, TRUE)");

var mysnippet = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5); temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \tmat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, nrow(mat) ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:nrow(mat)));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(nrow(mat))), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[nrow(mat), ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[nrow(mat), ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:nrow(mat)){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t}else { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:nrow(mat)){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:nrow(mat)){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet); \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = mat, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE)");

// var mysnippet = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5); temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \tmat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, nrow(mat) ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:nrow(mat)));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(nrow(mat))), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[nrow(mat), ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[nrow(mat), ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:nrow(mat)){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t}else { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:nrow(mat)){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:nrow(mat)){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet); \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = mat, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE)");
// var mysnippet = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5); temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \tmat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, nrow(mat) ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:nrow(mat)));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(nrow(mat))), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[nrow(mat), ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[nrow(mat), ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:nrow(mat)){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t}else { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:nrow(mat)){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:nrow(mat)){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet); \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = mat, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE)");
// var mysnippet = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5); temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \tmat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, nrow(mat) ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:nrow(mat)));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(nrow(mat))), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[nrow(mat), ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[nrow(mat), ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:nrow(mat)){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t}else { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:nrow(mat)){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:nrow(mat)){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet); \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = mat, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE)");

// var fxns = "E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5);";
// var maxi = " mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; diagSlack = NULL; newmat = NULL; tempstring = NULL; Simplex <- function(f, verbose){   matlist = NULL;   mat = AugCoeffMatrix(f)$augcoeffmatrix;   var = AugCoeffMatrix(f)$variables;   row = nrow(mat);         diagSlack = diag(x = 1, nrow(mat) );   for (k in 1:length(var)){     newmat = cbind (newmat, mat[,k]);   };   newmat = cbind(newmat, diagSlack);   newmat = cbind(newmat, mat[,ncol(mat)]);   mat = newmat;      col = ncol(mat);   slack = c(paste(\"s\", 1:nrow(mat), sep=\"\"));   label = c(var, slack, \"S\");      dimnames(mat)=list(c(1:row), label);   iter = 1;   solutionSet = c();   while( min(mat[nrow(mat), ]) < 0){     solutionSet = c();     pivotcol = which.min((mat[nrow(mat), ]));     temp = c();     for (i in 1:nrow(mat)){       x = as.numeric(mat[i, col]/mat[i,pivotcol]);       if(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){         temp = c(temp, Inf);       }else {         temp = c(temp, x);       };     };     pivotrow = as.numeric(which.min(abs(temp)));     mat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4);     for(j in 1:nrow(mat)){       if(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) {         next;       };       normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);       mat[j,] = round(mat[j,] - normalized, digits = 4);       if(verbose){         print(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE);         print(mat);       };     };      solutionSet = c();     for(j in 1:col){       cnt = 0;       for(k in 1:nrow(mat)){         if (mat[k,j] == 0){           cnt = cnt + 1;         };         if(mat[k,j] == 1){           temp = mat[k,col];         };       };       if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){         solutionSet = c(solutionSet, temp);       }else{         solutionSet = c(solutionSet, 0);       };     };     names(solutionSet)=label;     if(verbose){        print(paste(\"******************************************\"),quote = FALSE);       print(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE);       print(mat);       print(paste(\"Solution Set: \"),quote = FALSE);       print(solutionSet);       print(paste(\"******************************************\"),quote = FALSE);      };     matlist[[iter]] <- mat;     iter=iter+1;      if(min((mat[row, ]))>0) break;   };     if(verbose){     print(paste(\"Resulting Matrix for Simplex\"),quote = FALSE);     print(mat);     print(paste(\"Solution Set: \"),quote = FALSE);     print(solutionSet);   };   result = list(mat = matlist, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   return (result); };  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; Simplex(f, TRUE);"

var maxi = " mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; diagSlack = NULL; newmat = NULL; tempstring = NULL; Simplex <- function(f, verbose){   matlist = NULL;   mat = AugCoeffMatrix(f)$augcoeffmatrix;   var = AugCoeffMatrix(f)$variables;   row = nrow(mat);         diagSlack = diag(x = 1, nrow(mat) );   for (k in 1:length(var)){     newmat = cbind (newmat, mat[,k]);   };   newmat = cbind(newmat, diagSlack);   newmat = cbind(newmat, mat[,ncol(mat)]);   mat = newmat;      col = ncol(mat);   slack = c(paste(\"s\", 1:nrow(mat), sep=\"\"));   label = c(var, slack, \"S\");      dimnames(mat)=list(c(1:row), label);   iter = 1;   solutionSet = c();   while( min(mat[nrow(mat), ]) < 0){     solutionSet = c();     pivotcol = which.min((mat[nrow(mat), ]));     temp = c();     for (i in 1:nrow(mat)){       x = as.numeric(mat[i, col]/mat[i,pivotcol]);       if(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){         temp = c(temp, Inf);       }else {         temp = c(temp, x);       };     };     pivotrow = as.numeric(which.min(abs(temp)));     mat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4);     for(j in 1:nrow(mat)){       if(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) {         next;       };       normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);       mat[j,] = round(mat[j,] - normalized, digits = 4);       if(verbose){         print(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE);         print(mat);       };     };      solutionSet = c();     for(j in 1:col){       cnt = 0;       for(k in 1:nrow(mat)){         if (mat[k,j] == 0){           cnt = cnt + 1;         };         if(mat[k,j] == 1){           temp = mat[k,col];         };       };       if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){         solutionSet = c(solutionSet, temp);       }else{         solutionSet = c(solutionSet, 0);       };     };     names(solutionSet)=label;     if(verbose){        print(paste(\"******************************************\"),quote = FALSE);       print(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE);       print(mat);       print(paste(\"Solution Set: \"),quote = FALSE);       print(solutionSet);       print(paste(\"******************************************\"),quote = FALSE);      };     matlist[[iter]] <- mat;     iter=iter+1;      if(min((mat[row, ]))>0) break;   };     if(verbose){     print(paste(\"Resulting Matrix for Simplex\"),quote = FALSE);     print(mat);     print(paste(\"Solution Set: \"),quote = FALSE);     print(solutionSet);   };   result = list(mat = matlist, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   return (result); };  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; Simplex(f, TRUE);"
// var mini = " mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; diagSlack = NULL; newmat = NULL; tempstring = NULL; Simplex <- function(f, verbose){   matlist = NULL;   mat = AugCoeffMatrix(f)$augcoeffmatrix;   var = AugCoeffMatrix(f)$variables;   row = nrow(mat);  mat[row,] = mat[row,] * -1;    diagSlack = diag(x = 1, nrow(mat) );   for (k in 1:row){     newmat = cbind (newmat, mat[,k]);   };   newmat = cbind(newmat, diagSlack);   newmat = cbind(newmat, mat[,ncol(mat)]);   mat = newmat;      col = ncol(mat);       iter = 1;   solutionSet = c();   while( min(mat[nrow(mat), ]) < 0){     solutionSet = c();     pivotcol = which.min((mat[nrow(mat), ]));     temp = c();     for (i in 1:nrow(mat)){       x = as.numeric(mat[i, col]/mat[i,pivotcol]);       if(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){         temp = c(temp, Inf);       }else {         temp = c(temp, x);       };     };     pivotrow = as.numeric(which.min(abs(temp)));     mat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4);     for(j in 1:nrow(mat)){       if(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) {         next;       };       normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);       mat[j,] = round(mat[j,] - normalized, digits = 4);       if(verbose){         print(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE);         print(mat);       };     };      solutionSet = c();     for(j in 1:col){       cnt = 0;       for(k in 1:nrow(mat)){         if (mat[k,j] == 0){           cnt = cnt + 1;         };         if(mat[k,j] == 1){           temp = mat[k,col];         };       };       if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){         solutionSet = c(solutionSet, temp);       }else{         solutionSet = c(solutionSet, 0);       };     };     names(solutionSet)=label;     if(verbose){        print(paste(\"******************************************\"),quote = FALSE);       print(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE);       print(mat);       print(paste(\"Solution Set: \"),quote = FALSE);       print(solutionSet);       print(paste(\"******************************************\"),quote = FALSE);      };     matlist[[iter]] <- mat;     iter=iter+1;      if(min((mat[row, ]))>0) break;   };     if(verbose){     print(paste(\"Resulting Matrix for Simplex\"),quote = FALSE);     print(mat);     print(paste(\"Solution Set: \"),quote = FALSE);     print(solutionSet);   };   result = list(mat = matlist, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   return (result); };  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   }; mat=t(mat);   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; Simplex(f, TRUE);"
//trying
// var mini = " mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; diagSlack = NULL; newmat = NULL; tempstring = NULL; Simplex <- function(f, verbose){   matlist = NULL;   mat = AugCoeffMatrix(f)$augcoeffmatrix;   var = AugCoeffMatrix(f)$variables;   row = nrow(mat);  mat[row,] = mat[row,] * -1;    diagSlack = diag(x = 1, nrow(mat) );   for (k in 1:row){     newmat = cbind (newmat, mat[,k]);   };   newmat = cbind(newmat, diagSlack);   newmat = cbind(newmat, mat[,ncol(mat)]);   mat = newmat;      col = ncol(mat);       iter = 1;   solutionSet = c();      if(verbose){     print(paste(\"Resulting Matrix for Simplex\"),quote = FALSE);     print(mat);     print(paste(\"Solution Set: \"),quote = FALSE);     print(solutionSet);   };   result = list(mat = mat, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   return (result); };  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   }; mat=t(mat);   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; Simplex(f, TRUE);"
var mini = "mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; diagSlack = NULL; newmat = NULL; tempstring = NULL;  Simplex <- function(f, verbose){   matlist = NULL;   mat = AugCoeffMatrix(f)$augcoeffmatrix;   var = AugCoeffMatrix(f)$variables;   row = nrow(mat);   mat[row,] = mat[row,] *-1;      diagSlack = diag(x = 1, nrow(mat) );   for (k in 1:ncol(mat)-1){     newmat = cbind (newmat, mat[,k]);   };   newmat = cbind(newmat, diagSlack);   newmat = cbind(newmat, mat[,ncol(mat)]);   mat = newmat;        col = ncol(mat);       mat[,col] = mat[,col] *-1;      iter = 1;   solutionSet = c();   while( min(mat[nrow(mat), ]) < 0){     solutionSet = c();     pivotcol = which.min((mat[nrow(mat), ]));     temp = c();     for (i in 1:nrow(mat)){       x = as.numeric(mat[i, col]/mat[i,pivotcol]);       if(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){         temp = c(temp, Inf);       }else {         temp = c(temp, x);       };     };     pivotrow = as.numeric(which.min(abs(temp)));     mat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4);     for(j in 1:nrow(mat)){       if(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) {         next;       };       normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);       mat[j,] = round(mat[j,] - normalized, digits = 4);       if(verbose){         print(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE);         print(mat);       };     };      solutionSet = c();     for(j in 1:col){       cnt = 0;       for(k in 1:nrow(mat)){         if (mat[k,j] == 0){           cnt = cnt + 1;         };         if(mat[k,j] == 1){           temp = mat[k,col];         };       };       if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){         solutionSet = c(solutionSet, temp);       }else{         solutionSet = c(solutionSet, 0);       };     };     names(solutionSet)=label;     if(verbose){        print(paste(\"******************************************\"),quote = FALSE);       print(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE);       print(mat);       print(paste(\"Solution Set: \"),quote = FALSE);       print(solutionSet);       print(paste(\"******************************************\"),quote = FALSE);      };     matlist[[iter]] <- mat;     iter=iter+1;      if(min((mat[row, ]))>0) break;   };    if(verbose){     print(paste(\"Resulting Matrix for Simplex\"),quote = FALSE);     print(mat);     print(paste(\"Solution Set: \"),quote = FALSE);     print(solutionSet);   };   result = list(mat = matlist, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   return (result); };  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };      i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);              newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);                  if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];                    };       };       newval[length(vars)+1] = line[length(vars)+1];                     newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;              if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   print(mat);   newmat = t(mat);   print(mat);      row = nrow(mat);   result = list (variables=c(vars),augcoeffmatrix=newmat);   return (result); }; Simplex(f, TRUE);";
var dietmini = "equation<-NULL; pos<-NULL; ing<-NULL; variables<-c(); simplex <- function(mat, verbose=TRUE) {   mat = AugCoeffMatrix(mat)$augcoeffmatrix; mat = t(mat); mat[nrow(mat), ] = mat[nrow(mat), ] * -1;   mat = cbind(mat[ , 1:ncol(mat)-1], diag(nrow(mat)), mat[ , ncol(mat)]);   print(\"Given matrix\");   print(mat);   for (num in seq(1, 10000, by=1)) {     minNegPos = which.min(mat[nrow(mat), ]);     if(min(mat[nrow(mat), ]) >= 0) {       return(mat[nrow(mat), ]);     };          x = mat[ , minNegPos];          x = mat[ , ncol(mat)] / x;          x = x[1:length(x)-1];          minPosPos = which(x == min(x[which(x > 0)]));          mat[minPosPos, ] = mat[minPosPos, ] / mat[minPosPos, minNegPos];          for (i in seq(1, nrow(mat), by=1)) {       if (i == minPosPos) next;       mat[i, ] = mat[i,] - (mat[i, minNegPos] * mat[minPosPos, ]);      };          print(paste(\"Iteration \", num));      print(mat); };  return(mat);        };      AugCoeffMatrix <- function(system) {      for (i in seq(1, length(system), by=1)) {          current <- unlist(system[i]);     current <- deparse(current);          for (x in seq(2, length(current), by=1)) {       equation <- paste(equation, current[x], sep=\"\");     };     current = equation;     equation = NULL;          substr(current, nchar(current), nchar(current)) = \" \";          current <- strsplit(current, \"\\\\s+\");     current <- unlist(current);    for (y in seq(1, length(current), by=1)) {       if (is.na(as.numeric(current[y]))) {         current[y] <- \"\";       } else {         break;       };     };      variableIndex = grep(\"x\", current);          if (i > 1) {       if (csize != length(variableIndex)+1) {       };     };          csize <- length(variableIndex)+1;          for (x in seq(1, length(variableIndex), by=1)) {       pos[length(pos)+1] = as.numeric(substr(current[variableIndex[x]], 2, 3));     };          for (x in seq(1, length(variableIndex), by=1)) {       ing[length(ing)+1] = as.numeric(current[variableIndex[pos[x]]-2]);     };     for (x in seq(1, length(current), by=1)) {       if (substr(current[x], 1, 1) != \"x\") {         if (x == length(current)) {           ing[length(ing)+1] = current[x];         } else if (grepl(\"\\\\+\", current[x+1])) {            ing[length(ing)+1] = current[x];         };       };     };               pos = c();   };      ing <- as.numeric(ing);      for (i in seq(csize, length(ing), by=csize)) {     ing[i] = ing[i] * -1;   };      mat = matrix(c(ing), nrow=length(system), ncol=csize, byrow=TRUE);      for (i in seq(1, csize-1, by=1)) {     variables[length(variables)+1] = paste(\"x\", i, sep=\"\");   };         rownames(mat) <- 1:length(system);   colnames(mat) <- c(variables, \"RHS\");      return(list(variables=variables, augcoeffmatrix=mat));    }; simplex(f);";
var rString = "equation<-NULL; pos<-NULL; ing<-NULL; variables<-c(); simplex <- function(mat, verbose=TRUE) {   mat = AugCoeffMatrix(mat)$augcoeffmatrix; mat = t(mat); mat[nrow(mat), ] = mat[nrow(mat), ] * -1;   mat = cbind(mat[ , 1:ncol(mat)-1], diag(nrow(mat)), mat[ , ncol(mat)]);   print(\"Given matrix\");   print(mat);   for (num in seq(1, 10000, by=1)) {     minNegPos = which.min(mat[nrow(mat), ]);     if(min(mat[nrow(mat), ]) >= 0) {       return(mat[nrow(mat), ]);     };          x = mat[ , minNegPos];          x = mat[ , ncol(mat)] / x;          x = x[1:length(x)-1];          minPosPos = which(x == min(x[which(x > 0)]));          mat[minPosPos, ] = mat[minPosPos, ] / mat[minPosPos, minNegPos];          for (i in seq(1, nrow(mat), by=1)) {       if (i == minPosPos) next;       mat[i, ] = mat[i,] - (mat[i, minNegPos] * mat[minPosPos, ]);      };          print(paste(\"Iteration \", num));      print(mat); };  return(mat);        };      AugCoeffMatrix <- function(system) {      for (i in seq(1, length(system), by=1)) {          current <- unlist(system[i]);     current <- deparse(current);          for (x in seq(2, length(current), by=1)) {       equation <- paste(equation, current[x], sep=\"\");     };     current = equation;     equation = NULL;          substr(current, nchar(current), nchar(current)) = \" \";          current <- strsplit(current, \"\\\\s+\");     current <- unlist(current);    for (y in seq(1, length(current), by=1)) {       if (is.na(as.numeric(current[y]))) {         current[y] <- \"\";       } else {         break;       };     };      variableIndex = grep(\"x\", current);          if (i > 1) {       if (csize != length(variableIndex)+1) {       };     };          csize <- length(variableIndex)+1;          for (x in seq(1, length(variableIndex), by=1)) {       pos[length(pos)+1] = as.numeric(substr(current[variableIndex[x]], 2, 3));     };          for (x in seq(1, length(variableIndex), by=1)) {       ing[length(ing)+1] = as.numeric(current[variableIndex[pos[x]]-2]);     };     for (x in seq(1, length(current), by=1)) {       if (substr(current[x], 1, 1) != \"x\") {         if (x == length(current)) {           ing[length(ing)+1] = current[x];         } else if (grepl(\"\\\\+\", current[x+1])) {            ing[length(ing)+1] = current[x];         };       };     };               pos = c();   };      ing <- as.numeric(ing);      for (i in seq(csize, length(ing), by=csize)) {     ing[i] = ing[i] * -1;   };      mat = matrix(c(ing), nrow=length(system), ncol=csize, byrow=TRUE);      for (i in seq(1, csize-1, by=1)) {     variables[length(variables)+1] = paste(\"x\", i, sep=\"\");   };         rownames(mat) <- 1:length(system);   colnames(mat) <- c(variables, \"RHS\");      return(list(variables=variables, augcoeffmatrix=mat));    }; simplex(system);";





// var mini = " mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; diagSlack = NULL; newmat = NULL; tempstring = NULL; Simplex <- function(f, verbose){   matlist = NULL;   mat = AugCoeffMatrix(f)$augcoeffmatrix;   var = AugCoeffMatrix(f)$variables;   row = nrow(mat);  mat[row,] = mat[row,] *-1;      diagSlack = diag(x = 1, nrow(mat) );   for (k in 1:row){     newmat = cbind (newmat, mat[,k]);   };   newmat = cbind(newmat, diagSlack);   newmat = cbind(newmat, mat[,ncol(mat)]);   mat = newmat;     col = ncol(mat);      iter = 1;   solutionSet = c();   while( min(mat[nrow(mat), ]) < 0){     solutionSet = c();     pivotcol = which.min((mat[nrow(mat), ]));     temp = c();     for (i in 1:nrow(mat)){       x = as.numeric(mat[i, col]/mat[i,pivotcol]);       if(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){         temp = c(temp, Inf);       }else {         temp = c(temp, x);       };     };     pivotrow = as.numeric(which.min(abs(temp)));     mat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4);     for(j in 1:nrow(mat)){       if(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) {         next;       };       normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);       mat[j,] = round(mat[j,] - normalized, digits = 4);       if(verbose){         print(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE);         print(mat);       };     };          solutionSet = c();     for(j in 1:col){       cnt = 0;       for(k in 1:nrow(mat)){         if (mat[k,j] == 0){           cnt = cnt + 1;         };         if(mat[k,j] == 1){           temp = mat[k,col];         };       };       if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){         solutionSet = c(solutionSet, temp);       }else{         solutionSet = c(solutionSet, 0);       };     };     names(solutionSet)=label;     if(verbose){              print(paste(\"******************************************\"),quote = FALSE);       print(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE);       print(mat);       print(paste(\"Solution Set: \"),quote = FALSE);       print(solutionSet);       print(paste(\"******************************************\"),quote = FALSE);            };     matlist[[iter]] <- mat;     iter=iter+1;          if(min((mat[row, ]))>0) break;   };         if(verbose){     print(paste(\"Resulting Matrix for Simplex\"),quote = FALSE);     print(mat);     print(paste(\"Solution Set: \"),quote = FALSE);     print(solutionSet);   };   result = list(mat = matlist, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   return (result); };  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };      i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);              newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);                  if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];                    };       };       newval[length(vars)+1] = line[length(vars)+1];                     newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;              if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   print(mat);   newmat = t(mat);   print(mat);      row = nrow(mat);   result = list (variables=c(vars),augcoeffmatrix=newmat);   return (result); }; Simplex(f, TRUE);";
// uncomment this
// var mini = " mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; diagSlack = NULL; newmat = NULL; tempstring = NULL; Simplex <- function(f, verbose){   matlist = NULL;   mat = AugCoeffMatrix(f)$augcoeffmatrix;   var = AugCoeffMatrix(f)$variables;   row = nrow(mat);         diagSlack = diag(x = 1, nrow(mat) );   for (k in 1:row){     newmat = cbind (newmat, mat[,k]);   };   newmat = cbind(newmat, diagSlack);   newmat = cbind(newmat, mat[,ncol(mat)]);   mat = newmat;      col = ncol(mat);   iter = 1;   solutionSet = c();   while( min(mat[nrow(mat), ]) < 0){     solutionSet = c();     pivotcol = which.min((mat[nrow(mat), ]));     temp = c();     for (i in 1:nrow(mat)){       x = as.numeric(mat[i, col]/mat[i,pivotcol]);       if(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){         temp = c(temp, Inf);       }else {         temp = c(temp, x);       };     };     pivotrow = as.numeric(which.min(abs(temp)));     mat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4);     for(j in 1:nrow(mat)){       if(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) {         next;       };       normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);       mat[j,] = round(mat[j,] - normalized, digits = 4);       if(verbose){         print(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE);         print(mat);       };     };      solutionSet = c();     for(j in 1:col){       cnt = 0;       for(k in 1:nrow(mat)){         if (mat[k,j] == 0){           cnt = cnt + 1;         };         if(mat[k,j] == 1){           temp = mat[k,col];         };       };       if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){         solutionSet = c(solutionSet, temp);       }else{         solutionSet = c(solutionSet, 0);       };     };     names(solutionSet)=label;     if(verbose){        print(paste(\"******************************************\"),quote = FALSE);       print(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE);       print(mat);       print(paste(\"Solution Set: \"),quote = FALSE);       print(solutionSet);       print(paste(\"******************************************\"),quote = FALSE);      };     matlist[[iter]] <- mat;     iter=iter+1;      if(min((mat[row, ]))>0) break;   };     if(verbose){     print(paste(\"Resulting Matrix for Simplex\"),quote = FALSE);     print(mat);     print(paste(\"Solution Set: \"),quote = FALSE);     print(solutionSet);   };   result = list(mat = matlist, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   return (result); };  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };          result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; Simplex(f, TRUE);";



// var mini = " mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; diagSlack = NULL; newmat = NULL; tempstring = NULL;  Simplex <- function(f, verbose){ mat = AugCoeffMatrix(f)$augcoeffmatrix;   mat = t(mat); return(mat);}; AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   }; mat = t(mat);   row = nrow(mat);   tempstring = c(paste(\"x\", (length(vars)+1):(len-1), sep=\"\"));   vars = c(vars, tempstring);   dimnames(mat)=list(c(1:nrow(mat)), c(vars, \"RHS\"));       result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; Simplex(f, TRUE);";
// var mini = " mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; diagSlack = NULL; newmat = NULL; tempstring = NULL;  Simplex <- function(f, verbose){   matlist = NULL;   mat = AugCoeffMatrix(f)$augcoeffmatrix;   var = AugCoeffMatrix(f)$variables;   row = nrow(mat);   mat[row,] = mat[row,] *-1;      diagSlack = diag(x = 1, nrow(mat) );   for (k in 1:length(var)){     newmat = cbind (newmat, mat[,k]);   };   newmat = cbind(newmat, diagSlack);   newmat = cbind(newmat, mat[,ncol(mat)]);   mat = newmat;      col = ncol(mat);   slack = c(paste(\"s\", 1:nrow(mat), sep=\"\"));   label = c(var, slack, \"S\");      dimnames(mat)=list(c(1:row), label);   print(mat);      iter = 1;   solutionSet = c();   while( min(mat[nrow(mat), ]) < 0){     solutionSet = c();     pivotcol = which.min((mat[nrow(mat), ]));     temp = c();     for (i in 1:nrow(mat)){       x = as.numeric(mat[i, col]/mat[i,pivotcol]);       if(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){         temp = c(temp, Inf);       }else {         temp = c(temp, x);       };     };     pivotrow = as.numeric(which.min(abs(temp)));     mat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4);     for(j in 1:nrow(mat)){       if(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) {         next;       };       normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);       mat[j,] = round(mat[j,] - normalized, digits = 4);       if(verbose){         print(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE);         print(mat);       };     };          solutionSet = c();     for(j in 1:col){       cnt = 0;       for(k in 1:nrow(mat)){         if (mat[k,j] == 0){           cnt = cnt + 1;         };         if(mat[k,j] == 1){           temp = mat[k,col];         };       };       if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){         solutionSet = c(solutionSet, temp);       }else{         solutionSet = c(solutionSet, 0);       };     };     names(solutionSet)=label;     if(verbose){              print(paste(\"******************************************\"),quote = FALSE);       print(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE);       print(mat);       print(paste(\"Solution Set: \"),quote = FALSE);       print(solutionSet);       print(paste(\"******************************************\"),quote = FALSE);            };     matlist[[iter]] <- mat;     iter=iter+1;          if(min((mat[row, ]))>0) break;   };         if(verbose){     print(paste(\"Resulting Matrix for Simplex\"),quote = FALSE);     print(mat);     print(paste(\"Solution Set: \"),quote = FALSE);     print(solutionSet);   };   result = list(mat = matlist, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   return (result); };  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };      i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);              newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);                  if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];                    };       };       newval[length(vars)+1] = line[length(vars)+1];                     newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;              if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   mat = t(mat);   row = nrow(mat);   tempstring = c(paste(\"x\", (length(vars)+1):(len-1), sep=\"\"));   vars = c(vars, tempstring);   dimnames(mat)=list(c(1:nrow(mat)), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; Simplex(f, TRUE);";

var miniGANA = " mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; sslabel = NULL; iter = NULL; temp = NULL; varlen= NULL; z = NULL; slackCnt = NULL; cnter = NULL; newmat=NULL;  AugCoeffMatrix <- function(mylist){   tempstring = NULL;   i = 1;   row = NULL;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };      mat = t(mat);   row = nrow(mat);      tempstring = c(paste(\"x\", (length(vars)+1):(len-1), sep=\"\"));   vars = c(vars, tempstring);         dimnames(mat)=list(c(1:row), c(vars, \"RHS\"));      result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); };  Simplex <- function(f, verbose){   matlist = NULL;   mat = AugCoeffMatrix(f)$augcoeffmatrix;   var = AugCoeffMatrix(f)$variables;          row = nrow(mat);   mat[row,] = mat[row,] *-1;    diagSlack = diag(x = 1, length(var) );   slackCnt = ncol(diagSlack);         for (k in 1:length(var)){     newmat = cbind (newmat, mat[,k]);   };   newmat = cbind(newmat, diagSlack);   newmat = cbind(newmat, mat[,ncol(mat)]);   mat = newmat;         col = ncol(mat);   slack = c(paste(\"s\", 1:nrow(mat), sep=\"\"));   label = c(var, slack, \"S\");   dimnames(mat)=list(c(1:row), label);    iter = 1;   solutionSet = c();   while( min(mat[nrow(mat), ]) < 0){     solutionSet = c();     pivotcol = which.min((mat[nrow(mat), ]));     temp = c();     for (i in 1:nrow(mat)){       x = as.numeric(mat[i, col]/mat[i,pivotcol]);       if(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){         temp = c(temp, Inf);       }else {         temp = c(temp, x);       };     };     pivotrow = as.numeric(which.min(abs(temp)));     mat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4);     for(j in 1:nrow(mat)){       if(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) {         next;       };       normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);       mat[j,] = round(mat[j,] - normalized, digits = 4);       if(verbose){         print(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE);         print(mat);       };     };      solutionSet = c();     sslabel = c();          for(z in slackCnt:2){       solutionSet = c(solutionSet, mat[row, (col-z)] );     };     for(z in 2:slackCnt){       sslabel = c(sslabel, var[z]);     };     names(solutionSet)=sslabel;     if(verbose){        print(paste(\"******************************************\"),quote = FALSE);       print(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE);       print(mat);       print(paste(\"Solution Set: \"),quote = FALSE);       print(solutionSet);       print(paste(\"******************************************\"),quote = FALSE);      };     matlist[[iter]] <- mat;     iter=iter+1;      if(min((mat[row, ]))>0) break;   };     if(verbose){     print(paste(\"Resulting Matrix for Simplex\"),quote = FALSE);     print(mat);     print(paste(\"Solution Set: \"),quote = FALSE);     print(solutionSet);   };   result = list(mat = matlist, solutionSet = solutionSet);   return (result); };  Simplex(f, FALSE);";

//working maximization:
var code = " temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \t   matlist = NULL; \t mat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, nrow(mat) ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:nrow(mat), sep=\"\"));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(nrow(mat))), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[nrow(mat), ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[nrow(mat), ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:nrow(mat)){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t}else { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:nrow(mat)){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:nrow(mat)){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet); \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t matlist[[iter]] <- mat;    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = matlist, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE);";
// var snipetty = new ocpu.Snippet(fxn+code);

var mysnippet2 = new ocpu.Snippet(" temp = NULL; temp2 = NULL; var = NULL; mat = NULL; vars = NULL; line = NULL; index = NULL; dimnames = NULL; linelen = NULL; newval = NULL;  AugCoeffMatrix <- function(mylist){   i = 1;   l = c();   len = length(mylist);   for (i in 1:length(mylist)){     temp = deparse((mylist[[i]]));     l = c(l , temp);   };    i=1;   for (i in 1:length(l)){     if(i %% 2 == 0){       temp = l[i];       temp2 = unlist(strsplit(temp, \"[[:space:]]\"));       j=1;       vars = grep(\"x+\", temp2, perl=TRUE, value=TRUE);       line = grep(\"^[-+]?[0-9]*\\\\.?[0-9]+\", temp2, perl=TRUE, value=TRUE);        newval = c();       for (x in 1:length(vars)){         index = substring(vars[x],2);         index = as.numeric(index);          if (x == index ){           newval = c(newval, line[x]);         }         else{           newval[index] = line[x];          };       };       newval[length(vars)+1] = line[length(vars)+1];         newval = as.numeric(newval);       linelen = length(newval);       newval[linelen] = newval[linelen]*-1;        if (i == 2){         mat = newval;       }else{         mat = rbind(mat, newval);       };     };   };   dimnames(mat)=list(c(1:len), c(vars, \"RHS\"));   result = list (variables=c(vars),augcoeffmatrix=mat);   return (result); }; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL; mat = NULL; var = NULL; x = NULL; row = NULL; col = NULL; pivotcol = NULL; pivotrow = NULL; i = NULL; j = NULL; k = NULL; normalized = NULL; cnt = NULL; names = NULL; slack = NULL; label = NULL; solutionSet = NULL; iter = NULL; temp = NULL;  Simplex <- function(f, verbose){ \tmat = AugCoeffMatrix(f)$augcoeffmatrix;   \tvar = AugCoeffMatrix(f)$variables;   \trow = nrow(mat); \tmat = cbind (mat[,1], mat[,2], diag(x = 1, nrow(mat) ), mat[,3]); \tcol = ncol(mat);   \tslack = c(paste(\"s\", 1:nrow(mat), sep=\"\"));   \tlabel = c(var, slack, \"S\");   \tdimnames(mat)=list(c(1:(nrow(mat))), label); \titer = 1; \tsolutionSet = c(); \twhile( min(mat[nrow(mat), ]) < 0){ \t\tsolutionSet = c(); \t\tpivotcol = which.min((mat[nrow(mat), ]));\t\t \t\ttemp = c(); \t\tfor (i in 1:nrow(mat)){\t\t\t \t\t\tx = as.numeric(mat[i, col]/mat[i,pivotcol]); \t\t\tif(as.numeric(mat[i, col] == 0) || ( x == Inf) || ( x < 0)  ){ \t\t\t temp = c(temp, Inf); \t\t\t}else { \t\t\t\ttemp = c(temp, x); \t\t\t};\t\t \t\t}; \t\tpivotrow = as.numeric(which.min(abs(temp))); \t\tmat[pivotrow, ] = round(mat[pivotrow, ] / as.numeric(mat[pivotrow, pivotcol]), digits = 4); \t\tfor(j in 1:nrow(mat)){ \t      \tif(as.numeric(mat[j,pivotcol]) == 0 || (j == pivotrow)) { \t      \t\tnext; \t      \t}; \t        normalized =  round(mat[pivotrow,] * as.numeric(mat[j,pivotcol]), digits = 4);  \t        mat[j,] = round(mat[j,] - normalized, digits = 4);  \t\t\tif(verbose){ \t\t\t\tprint(paste(\"Resulting Matrix after new eval_row\", j, \"iteration\", iter),quote = FALSE); \t\t\t\tprint(mat); \t\t\t}; \t    };  \t   solutionSet = c(); \t    for(j in 1:col){ \t    \tcnt = 0; \t    \t for(k in 1:nrow(mat)){ \t\t    \tif (mat[k,j] == 0){ \t\t    \t\tcnt = cnt + 1; \t\t\t    }; \t\t\t    if(mat[k,j] == 1){ \t\t\t    \ttemp = mat[k,col]; \t\t\t    }; \t\t    }; \t\t    if ( (max(mat[ ,j]) == 1 ) && (cnt<=nrow(mat) || (cnt==(nrow(mat)-1)))){ \t\t    \tsolutionSet = c(solutionSet, temp); \t\t    }else{ \t\t    \tsolutionSet = c(solutionSet, 0); \t\t    }; \t\t}; \t\tnames(solutionSet)=label; \t    if(verbose){ \t    \t \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t \t\t\tprint(paste(\"Resulting Matrix after Iteration\", iter),quote = FALSE); \t\t\tprint(mat); \t\t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\t\tprint(solutionSet); \t\t\tprint(paste(\"******************************************\"),quote = FALSE);\t  \t\t}; \t    iter=iter+1; \t\tif(min((mat[row, ]))>0) break; \t}; \tif(verbose){ \t\tprint(paste(\"Resulting Matrix for Simplex\"),quote = FALSE); \t\tprint(mat); \t\tprint(paste(\"Solution Set: \"),quote = FALSE);\t \t\tprint(solutionSet); \t};   \tresult = list(mat = mat, solutionSet = solutionSet, x1 = solutionSet[1], x2 = solutionSet[2]);   \treturn (result); }; Simplex(f, TRUE)");


var fxns = new ocpu.Snippet("E1 <- function (x1, x2) 7 * x1 + 11 * x2 + -77; E2 <- function (x1, x2) 10 * x1 + 8 * x2 + -80; E3 <- function (x1, x2) 1 * x1 + 0 * x2 + -9; E4 <- function (x1, x2) 0 * x1 + 1 * x2 + -6; E5 <- function (x1, x2) -150 * x1 + -175 * x2 + 0; f <- list(E1, E2, E3, E4, E5);");